package pathx.data;

import java.awt.Graphics;
import java.awt.Image;
import java.awt.geom.Line2D;
import pathx.data.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.Iterator;
import pathx.PathX.PathXPropertyType;
import mini_game.MiniGame;
import mini_game.MiniGameDataModel;
import mini_game.SpriteType;
import mini_game.Sprite;
import mini_game.Viewport;
import properties_manager.PropertiesManager;
import static pathx.PathXConstants.*;
import pathx.ui.PathXMiniGame;
import pathx.ui.PathXPanel;
import pathx.ui.PathXState;

/**
 * This class manages the game data for PathX.
 * 
 * @author Brian Sabz
 */
public class PathXDataModel extends MiniGameDataModel{

    // THIS CLASS HAS A REFERERENCE TO THE MINI GAME SO THAT IT
    // CAN NOTIFY IT TO UPDATE THE DISPLAY WHEN THE DATA MODEL CHANGES
    private MiniGame miniGame;
    private PathXMiniGame mG;
    // THIS STORES THE TILES ON THE GRID DURING THE GAME
    private ArrayList<Sprite> playerSprite;
    private ArrayList<Sprite> charSprites;
    
    // GAME GRID AND TILE DATA
    private int numGameGridColumns;
    private int numGameGridRows;
    
     // THESE ARE USED FOR TIMING THE GAME
    private GregorianCalendar startTime;
    private GregorianCalendar endTime;

    // LEVEL
    private String currentLevel;
    
    // THIS IS THE LEVEL CURRENTLY BEING EDITING
    private PathXLevel level;

    // DATA FOR RENDERING
   // Viewport viewport;
    
    // WE ONLY NEED TO TURN THIS ON ONCE
    private Image backgroundImage;
    private Image startingLocationImage;
    private Image destinationImage;

//    // THE SELECTED INTERSECTION OR ROAD MIGHT BE EDITED OR DELETED
//    // AND IS RENDERED DIFFERENTLY
//    private Intersection selectedIntersection;
//    private Road selectedRoad;
//    
//    // WE'LL USE THIS WHEN WE'RE ADDING A NEW ROAD
    private Intersection startRoadIntersection;
//    
//    // IN CASE WE WANT TO TRACK MOVEMENTS
//    int lastMouseX;
//    int lastMouseY;    
//    
//    // THESE BOOLEANS HELP US KEEP TRACK OF
//    // @todo DO WE NEED THESE?
//    boolean isMousePressed;
//    boolean isDragging;
//    boolean dataUpdatedSinceLastSave;
//
//    // THIS IS THE UI, WE'LL NOTIFY IT WHENEVER THE DATA CHANGES SO
//    // THAT THE UI RENDERING CAN BE UPDATED AT THAT TIME
//    PathXPanel view;
//    
    //LEVEL SELECT ATTRIBUTES
    private int balance;
    private int goal;
    private int [] moneyEarned = {100,120,140,160,180,200,220,240,260,280,300,320,340,360,380,400,420,440,460,480,500};
    private String[] levelName = {"San Diego, Cali", "San Francisco, Cali", "Los Angeles, Cali",
                                  "Silicon Valley, Cali", "Oracle, Cali", "Google, Cali",
                                  "Bellagio, Vegas", "MGM, Vegas", "Cosmopolitan, Vegas",
                                  "Dodge City, Kansas", "Springfield, Missouri", "Okc, Oklahoma",
                                  "Tampa, Florida", "Orlando, Florida", "Miami, Florida",
                                  "South of the Border", "Congress", "Fort Knox",
                                  "Long Island, NY", "5th Ave, NY", "Wall Street, NY"};
    
    
    /**
     * Constructor for initializing this data model, it will create the data
     * structures for storing tiles, but not the tile grid itself, that is
     * dependent on file loading, and so should be subsequently initialized.
     *
     * @param initMiniGame PathX game UI.
     */
    public PathXDataModel(MiniGame initMiniGame)
    {
        // KEEP THE GAME FOR LATER
        miniGame = initMiniGame;
        mG = (PathXMiniGame)initMiniGame;
        
        playerSprite = new ArrayList();
        charSprites = new ArrayList();
                
        balance = 0;
        goal = 10000;
        
       // viewport = new Viewport();
        level = new PathXLevel();
        startRoadIntersection = null;
        /*levelName = new ArrayList<String>();
        moneyEarned = new ArrayList<String>();*/
    }
    
     // ACCESSOR METHODS
     public int getNumGameGridColumns()
    {   return numGameGridColumns;  }
    public int getNumGameGridRows()
    {   return numGameGridRows; }
    public String getCurrentLevel()
    {   return currentLevel;    }
    
    
    
    // MUTATOR METHODS
    public void setCurrentLevel(String initCurrentLevel)
    {
        currentLevel = initCurrentLevel;
    }
    
    public PathXLevel       getLevel()                  {   return level;                   }
 //   public PathXPanel        getView()                  {   return view;                    }
    public Viewport         getViewport()               {   return viewport;                }
    public Image            getBackgroundImage()        {   return backgroundImage;         }
    public Image            getStartingLocationImage()  {   return startingLocationImage;   }
    public Image            getDesinationImage()        {   return destinationImage;        }
//    public Intersection     getSelectedIntersection()   {   return selectedIntersection;    }
//    public Road             getSelectedRoad()           {   return selectedRoad;            }
    public Intersection     getStartRoadIntersection()  {   return startRoadIntersection;   }
    public int              getLastMouseX()             {   return lastMouseX;              }
    public int              getLastMouseY()             {   return lastMouseY;              }
    public Intersection     getStartingLocation()       {   return level.startingLocation;  }
    public Intersection     getDestination()            {   return level.destination;       }
//    public boolean          isDataUpdatedSinceLastSave(){   return dataUpdatedSinceLastSave;}    
    public boolean          isStartingLocation(Intersection testInt)  
    {   return testInt == level.startingLocation;           }
    public boolean isDestination(Intersection testInt)
    {   return testInt == level.destination;                }
//    public boolean isSelectedIntersection(Intersection testIntersection)
//    {   return testIntersection == selectedIntersection;    }
//    public boolean isSelectedRoad(Road testRoad)
//    {   return testRoad == selectedRoad;                    }

    // ITERATOR METHODS FOR GOING THROUGH THE GRAPH

    public Iterator intersectionsIterator()
    {
        ArrayList<Intersection> intersections = level.getIntersections();
        return intersections.iterator();
    }
    public Iterator roadsIterator()
    {
        ArrayList<Road> roads = level.roads;
        return roads.iterator();
    }
        
//    // MUTATOR METHODS
//
//    public void setView(PathXPanel initView)
//    {   view = initView;    }
//    public void setLastMousePosition(int initX, int initY)
//    {
//        lastMouseX = initX;
//        lastMouseY = initY;
//        view.getCanvas().repaint();
//    }    
//    public void setSelectedIntersection(Intersection i)
//    {
//        selectedIntersection = i;
//        selectedRoad = null;
//        view.getCanvas().repaint();
//    }    
//    public void setSelectedRoad(Road r)
//    {
//        selectedRoad = r;
//        selectedIntersection = null;
//        view.getCanvas().repaint();
//    }
//    
//    // AND THEN ALL THE SERVICE METHODS FOR UPDATING THE LEVEL
//    // AND APP STATE
//
//    /**
//     * For selecting the first intersection when making a road. It will
//     * find the road at the (canvasX, canvasY) location.
//     */
//    public void selectStartRoadIntersection(int canvasX, int canvasY)
//    {
//        startRoadIntersection = findIntersectionAtCanvasLocation(canvasX, canvasY);
//        if (startRoadIntersection != null)
//        {
//            // NOW WE NEED THE SECOND INTERSECTION
//           // switchEditMode(PXLE_EditMode.ADDING_ROAD_END);
//        }
//    }
//    
//    /**
//     * For selecting the second intersection when making a road. It will
//     * find the road at the (canvasX, canvasY) location.
//     */
//    public void selectEndRoadIntersection(int canvasX, int canvasY)
//    {
//        Intersection endRoadIntersection = findIntersectionAtCanvasLocation(canvasX, canvasY);
//        if (endRoadIntersection != null)
//        {
//            // MAKE AND ADD A NEW ROAD
//            Road newRoad = new Road();
//            newRoad.node1 = startRoadIntersection;
//            newRoad.node2 = endRoadIntersection;
//            newRoad.oneWay = false;
//            newRoad.speedLimit = DEFAULT_SPEED_LIMIT;
//            level.roads.add(newRoad);
//            
//            // AND LET'S GO BACK TO ADDING ANOTHER ROAD
//            //switchEditMode(PXLE_EditMode.ADDING_ROAD_START);
//            startRoadIntersection = null;
//
//            // RENDER
//            view.getCanvas().repaint();
//        }
//    }
    
    // INIT METHODS - AFTER CONSTRUCTION, THESE METHODS SETUP A GAME FOR USE
    // - initLevel
    // - initTiles
    // - initTile
    /**
     * Called after a level has been selected, it initializes the grid so that
     * it is the proper dimensions.
     */
    public void initLevel(String levelName)
    {
        /* KEEP THE TILE ORDER AND SORTING ALGORITHM FOR LATER
        snake = initSnake;
        sortingAlgorithm = initSortingAlgorithm;*/

        // UPDATE THE VIEWPORT IF WE ARE SCROLLING (WHICH WE'RE NOT)
        viewport.updateViewportBoundaries();

        /* INITIALIZE THE PLAYER RECORD IF NECESSARY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IT IS NECESSARY
        PathXRecord playerRecord = ((PathXMiniGame) miniGame).getPlayerRecord();
        if (!playerRecord.hasLevel(levelName))
        {
            playerRecord.addLevel(levelName, initSortingAlgorithm.name);
        }*/
    }
    
    /**
     * Updates the background image.
     */
    public void updateBackgroundImage(String newBgImage)
    {
        
        // UPDATE THE LEVEL TO FIT THE BACKGROUDN IMAGE SIZE
        level.backgroundImageFileName = newBgImage;
        backgroundImage = mG.loadImage(LEVELS_PATH + level.backgroundImageFileName);
        int levelWidth = backgroundImage.getWidth(null);
        int levelHeight = backgroundImage.getHeight(null);
        viewport.setLevelDimensions(levelWidth, levelHeight);
        mG.getCanvas().repaint();
    }
    
    /**
     * Updates the image used for the starting location and forces rendering.
     */
    public void updateStartingLocationImage(String newStartImage)
    {
        level.startingLocationImageFileName = newStartImage;
        startingLocationImage = mG.loadImage(LEVELS_PATH + level.startingLocationImageFileName);
        mG.getCanvas().repaint();
    }

    /**
     * Updates the image used for the destination and forces rendering.
     */
    public void updateDestinationImage(String newDestImage)
    {
        level.destinationImageFileName = newDestImage;
        destinationImage = mG.loadImage(LEVELS_PATH + level.destinationImageFileName);
        mG.getCanvas().repaint();
    }

//    /**
//     * Used for scrolling the viewport by (incX, incY). Note that it won't
//     * let the viewport scroll off the level.
//     */
//    public void moveViewport(int incX, int incY)
//    {
//        // MOVE THE VIEWPORT
//        viewport.scroll(incX, incY);
//
//        // AND NOW FORCE A REDRAW
//        view.getCanvas().repaint();
//    }

//    /**
//     * Adds an intersection to the graph
//     */
//    public void addIntersection(Intersection intToAdd)
//    {
//        ArrayList<Intersection> intersections = level.getIntersections();
//        intersections.add(intToAdd);
//        view.getCanvas().repaint();
//    }

    /**
     * Calculates and returns the distance between two points.
     */
    public double calculateDistanceBetweenPoints(int x1, int y1, int x2, int y2)
    {
        double diffXSquared = Math.pow(x1 - x2, 2);
        double diffYSquared = Math.pow(y1 - y2, 2);
        return Math.sqrt(diffXSquared + diffYSquared);
    }

//    /**
//     * Moves the selected intersection to (canvasX, canvasY),
//     * translating it into level coordinates.
//     */
//    public void moveSelectedIntersection(int canvasX, int canvasY)
//    {
//        selectedIntersection.x = canvasX + viewport.getViewportX();
//        selectedIntersection.y = canvasY + viewport.getViewportY();
//        view.getCanvas().repaint();
//    }

    /**
     * Searches the level graph and finds and returns the intersection
     * that overlaps (canvasX, canvasY).
     */
    public Intersection findIntersectionAtCanvasLocation(int canvasX, int canvasY)
    {
        // CHECK TO SEE IF THE USER IS SELECTING AN INTERSECTION
        for (Intersection i : level.intersections)
        {
            double distance = calculateDistanceBetweenPoints(i.x, i.y, canvasX + viewport.getViewportX(), canvasY + viewport.getViewportY());
            if (distance < INTERSECTION_RADIUS)
            {
                // MAKE THIS THE SELECTED INTERSECTION
                return i;
            }
        }
        return null;
    }

//    /**
//     * Deletes the selected item from the graph, which might be either
//     * an intersection or a road.
//     */
//    public void deleteSelectedItem()
//    {
//        // DELETE THE SELECTED INTERSECTION, BUT MAKE SURE IT'S 
//        // NOT THE STARTING LOCATION OR DESTINATION
//        if ((selectedIntersection != null)
//                && (selectedIntersection != level.startingLocation)
//                && (selectedIntersection != level.destination))
//        {
//            // REMOVE ALL THE ROADS THE INTERSECTION IS CONNECTED TO
//            ArrayList<Road> roadsMarkedForDeletion = new ArrayList();
//            for (Road r : level.roads)
//            {
//                if ((r.node1 == selectedIntersection)
//                        || (r.node2 == selectedIntersection))
//                    roadsMarkedForDeletion.add(r);
//            }
//            
//            // NOW REMOVE ALL THE ROADS MARKED FOR DELETION
//            for (Road r : roadsMarkedForDeletion)
//            {
//                level.roads.remove(r);
//            }
//            
//            // THEN REMOVE THE INTERSECTION ITSELF
//            level.intersections.remove(selectedIntersection);
//            
//            // AND FINALLY NOTHING IS SELECTED ANYMORE
//            selectedIntersection = null;
//           // switchEditMode(PXLE_EditMode.NOTHING_SELECTED);            
//        }
//        // THE SELECTED ITEM MIGHT BE A ROAD
//        else if (selectedRoad != null)
//        {
//            // JUST REMOVE THE NODE, BUT NOT ANY OF THE INTERSECTIONS
//            level.roads.remove(selectedRoad);
//            selectedRoad = null;
//           // switchEditMode(PXLE_EditMode.NOTHING_SELECTED);
//        }
//    }
//    
//    /**
//     * Unselects any intersection or road that might be selected.
//     */
//    public void unselectEverything()
//    {
//        selectedIntersection = null;
//        selectedRoad = null;
//        startRoadIntersection = null;
//        view.getCanvas().repaint();
//    }

//    /**
//     * Searches to see if there is a road at (canvasX, canvasY), and if
//     * there is, it selects and returns it.
//     */
//    public Road selectRoadAtCanvasLocation(int canvasX, int canvasY)
//    {
//        Iterator<Road> it = level.roads.iterator();
//        Line2D.Double tempLine = new Line2D.Double();
//        while (it.hasNext())
//        {
//            Road r = it.next();
//            tempLine.x1 = r.node1.x;
//            tempLine.y1 = r.node1.y;
//            tempLine.x2 = r.node2.x;
//            tempLine.y2 = r.node2.y;
//            double distance = tempLine.ptSegDist(canvasX+viewport.getViewportX(), canvasY+viewport.getViewportX());
//            
//            // IS IT CLOSE ENOUGH?
//            if (distance <= INT_STROKE)
//            {
//                // SELECT IT
//                this.selectedRoad = r;
//                //this.switchEditMode(PXLE_EditMode.ROAD_SELECTED);
//                return selectedRoad;
//            }
//        }
//        return null;
//    }
//
//    /**
//     * Checks to see if (canvasX, canvasY) is free (i.e. there isn't
//     * already an intersection there, and if not, adds one.
//     */
//    public void addIntersectionAtCanvasLocation(int canvasX, int canvasY)
//    {
//        // FIRST MAKE SURE THE ENTIRE INTERSECTION IS INSIDE THE LEVEL
//        if ((canvasX - INTERSECTION_RADIUS) < 0) return;
//        if ((canvasY - INTERSECTION_RADIUS) < 0) return;
//        if ((canvasX + INTERSECTION_RADIUS) > viewport.getGameWorldWidth()) return;
//        if ((canvasY + INTERSECTION_RADIUS) > viewport.getGameWorldHeight()) return;
//        
//        // AND ONLY ADD THE INTERSECTION IF IT DOESN'T OVERLAP WITH
//        // AN EXISTING INTERSECTION
//        for(Intersection i : level.intersections)
//        {
//            double distance = calculateDistanceBetweenPoints(i.x-viewport.getViewportX(), i.y-viewport.getViewportY(), canvasX, canvasY);
//            if (distance < INTERSECTION_RADIUS)
//                return;
//        }          
//        
//        // LET'S ADD A NEW INTERSECTION
//        int intX = canvasX + viewport.getViewportX();
//        int intY = canvasY + viewport.getViewportY();
//        Intersection newInt = new Intersection(intX, intY);
//        level.intersections.add(newInt);
//        view.getCanvas().repaint();
//    }
    
    /**
     * Retrieves the money, police, bandits, and zombies stats from
     * the view and uses it to refresh the level values.
     */
    public void refreshLevelStats()
    {
        /*if (!view.isRefreshingSpinners())
        {
            // GET THE DATA FROM THE VIEW
            int money = view.getCurrentMoney();
            int numPolice = view.getCurrentPolice();
            int numBandits = view.getCurrentBandits();
            int numZombies = view.getCurrentZombies();
        
            // AND USE IT TO UPDATE THE LEVEL
            level.setMoney(money);
            level.setNumPolice(numPolice);
            level.setNumBandits(numBandits);
            level.setNumZombies(numZombies);
        }*/
    }

//    /**
//     * Increases the speed limit on the selected road.
//     */
//    public void increaseSelectedRoadSpeedLimit()
//    {
//        if (selectedRoad != null)
//        {
//            int speedLimit = selectedRoad.getSpeedLimit();
//            if (speedLimit < MAX_SPEED_LIMIT)
//            {
//                speedLimit += SPEED_LIMIT_STEP;
//                selectedRoad.setSpeedLimit(speedLimit);
//                view.getCanvas().repaint();
//            }
//        }
//    }
//
//    /**
//     * Decreases the speed limit on the selected road.
//     */
//    public void decreaseSelectedRoadSpeedLimit()
//    {
//        if (selectedRoad != null)
//        {
//            int speedLimit = selectedRoad.getSpeedLimit();
//            if (speedLimit > MIN_SPEED_LIMIT)
//            {
//                speedLimit -= SPEED_LIMIT_STEP;
//                selectedRoad.setSpeedLimit(speedLimit);
//                view.getCanvas().repaint();
//            }
//        }
//    }    
//
//    /**
//     * Toggles the selected road, making it one way if it's currently
//     * two-way, and two-way if it's currently one way.
//     */
//    public void toggleSelectedRoadOneWay()
//    {
//        if (selectedRoad != null)
//        {
//            selectedRoad.setOneWay(!selectedRoad.isOneWay());
//            view.getCanvas().repaint();
//        }
//    }
    
    /**
     * Used to calculate the x-axis pixel location in the game grid for a tile
     * placed at column with stack position z.
     *
     * @param column The column in the grid the tile is located.
     *
     * @return The x-axis pixel location of the tile
     */
    public int calculateGridTileX(int column)
    {
        return viewport.getViewportMarginLeft() + (column * TILE_WIDTH) - viewport.getViewportX();
    }

    /**
     * Used to calculate the y-axis pixel location in the game grid for a tile
     * placed at row.
     *
     * @param row The row in the grid the tile is located.
     *
     * @return The y-axis pixel location of the tile
     */
    public int calculateGridTileY(int row)
    {
        return viewport.getViewportMarginTop() + (row * TILE_HEIGHT) - viewport.getViewportY();
    }

    /**
     * Used to calculate the grid column for the x-axis pixel location.
     *
     * @param x The x-axis pixel location for the request.
     *
     * @return The column that corresponds to the x-axis location x.
     */
    public int calculateGridCellColumn(int x)
    {
        // ADJUST FOR THE MARGIN
        x -= viewport.getViewportMarginLeft();

        // ADJUST FOR THE VIEWPORT
        x = x + viewport.getViewportX();

        if (x < 0)
        {
            return -1;
        }

        // AND NOW GET THE COLUMN
        return x / TILE_WIDTH;
    }

    /**
     * Used to calculate the grid row for the y-axis pixel location.
     *
     * @param y The y-axis pixel location for the request.
     *
     * @return The row that corresponds to the y-axis location y.
     */
    public int calculateGridCellRow(int y)
    {
        // ADJUST FOR THE MARGIN
        y -= viewport.getViewportMarginTop();

        // ADJUST FOR THE VIEWPORT
        y = y + viewport.getViewportY();

        if (y < 0)
        {
            return -1;
        }

        // AND NOW GET THE ROW
        return y / TILE_HEIGHT;
    }
    
    @Override
    public void checkMousePressOnSprites(MiniGame game, int x, int y) {
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void reset(MiniGame game) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateAll(MiniGame game) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateDebugText(MiniGame game) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
    
    //GETTERS
    public int getGoal()                      { return goal; }
    public int getBalance()                   { return balance; }
    public int []getMoneyEarned()             { return moneyEarned; }
    public String []getLevelName()            { return levelName; }
    public ArrayList<Sprite> getPlayerSprite(){ return playerSprite; }
    public ArrayList<Sprite> getCharSprites() { return charSprites; }
    public Image getDestinationImage()        { return destinationImage; }

    //SETTERS
    public void setBalance(int balance)                               {this.balance = balance;}
    public void setGoal(int goal)                                     {this.goal = goal;}
    public void setLevel(PathXLevel level)                            {this.level = level;}
    public void setBackgroundImage(Image backgroundImage)             {this.backgroundImage = backgroundImage;}
    public void setStartingLocationImage(Image startingLocationImage) {this.startingLocationImage = startingLocationImage;}
    public void setDestinationImage(Image destinationImage)           {this.destinationImage = destinationImage;}
 //   public void setStartRoadIntersection(Intersection startRoadIntersection) {this.startRoadIntersection = startRoadIntersection;} 
}
